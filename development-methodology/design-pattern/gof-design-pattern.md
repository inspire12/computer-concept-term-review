# GoF의 디자인 패턴
- 패턴은 '어떤 상황의 문제에 대한 해법'
- 패턴의 구조
    - 패턴 이름
    - 문제
    - 해법
    - 결과
## 책의 구조
- 디자인패턴이란?
- 객체 지향 어떻게 도움이 되는지
- 기존 설계 개념을 정리한 문서

### 디자인 패턴의 카탈로그  -> 표준적인 이름을 쓰고 남들과 의사소통
* 전문성의 문서화

* 객체지향의 방향 : 재사용성, 확장성
### 거대한 시스템에 대한 이해

### 리펙토링

### 객체지향 소프트웨어의 생명주기 : 프로토타이핑, 확장, 통합
 - 신속한 시제품화 

### 디자인 패턴에서 기대하는 바
-> 소프트웨어의 요구조건 만족 / 소프트웨어 재사용성 증가

## 카탈로그 -> 이름을 보고 구조를 그릴 수 있도록, 설명은 부수적

1. 추상 팩토리: 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 <strong>인터페이스를 제공</strong>하는 패턴  
2. Adapter : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 도움  
3. Bridge : 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴
4. Builder : 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴

6. Command : 요청을 객체의 형태로 캡슐화하여, 서로 요청이 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산 취소를 지원하게 만드는 패턴
7. Composite : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 함
8. Decorator : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴, 기능 확장이 필요할 때 서브클래싱 대신 쓸 수 있는 유연한 대안
9. Facade : 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴, 서브시스템을 좀 더 사용하기 편하게 만드는 상위 수준의 인터페이스를 정의
10. Factory Method : 객체를 생성하는 인터페이스
13. Iterator : 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴
16. Observer : 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지 받고자동으로 갱신될 수 있게 만드는 패턴
17. Prototype : 생성할 객체의 종류를 명세화하는 데에 원형이 되는 예시를 이용하고, 그 원형을 복사함으로써 새로운 객체를 생성하는 패턴
18. Proxy : 어떤 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자 또는 자리채움자를 제공하는 패턴 surrogate, placeholder
19. Singleton : 어떤 클래스의 인스턴스는 오직 하나임을 보장하며, 이 인스턴스에 접근할 수 있는 전역적인 접촉점을 제공 -> 인스턴스는 오직 하나!!


모름
5. Chain of Responsibility : 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여하여 요청을 보내는 객체와 그 요청을 받는 객체 사이의 결합을 피하는 패턴  

11. Flyweight : 크기가 작은 객체가 여러 개 있을 때, 공유를 통해 이들을 효율적으로 지원하는 패턴 - 공유? 어떤 식으로
12. Interpreter : 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 아울러 그 표현 수단을 사용하여 해당 언어로 작서오딘 문장을 해석하는 해석기를 정의하는 패턴?
14. Mediator : 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 객체를 정의하는 패턴. 객체들이 직접 서로를 참조하지 않도록 함-> 객체들간의 소결합을 촉진시키며, 개발자가 객체들의 상호작용을 독립적으로 다양화시킬 수 있게 만듭니다.
15. Memento : 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴 -> 되돌아?
20. State : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게끔 허가하는 패턴, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임
21. Strategy : 알고리즘 단위로 캡슐화, 이들을상호교환이 가능하도록 만드는 패턴.
22. Template Method : 객체의 연산에는 알고리즘의 뼈대만을 정의하고, 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미루는 패턴, 알고리즘 구조 자체는 그대로 놔둔 채 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있도록함
23. Visitor 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 할

설명 구조
    패턴 이름과 부류
    의도
    동기
    활용성
    구조
    참여자 : 주어진 패턴을 구성하고 책임을 수행하는 클래스나 객체


서사 구조


## 용어 정리
 - 디자인 패턴 : 디자인 패턴은 객체지향 시스템 설계문제를 해결하는 일반적 설계 개념을 설명하고 이에 대한 이름을 제공.
    - 설계 문제
    - 해법
    - 해법을 언제 적용해야 할지
    - 그 결과가 무엇인지 설명
 에 대해 설명. 해법은 문제를 해결하는 클래스와 객체의 배열이며, 어떤 특정 상황에서 문제를 해결하기 위해서 해ㅂ버을 재정의하거나 재구축할 수 있다.

 - mixin class : 상속을 통해 다른 클래스들과 구성할 수 있도록 설계된 클래스로 추상 클래스를 사용

- 위임 : 객체가 요청을 다른 객체에 전달하는 구현 방법. 대리 객체는 원본 객체를 대신해 요청 처리

- 클래스 다이어그램 : 클래스와 클래스 간의 관계나 구조를 표현
- 객체 다이어그램은 런타임의 객체 구조
- 상호작용 다이어그램 : 객체 간 요청 흐름
- 복합 객체 : 객체가 데이터나 함수 같은 작은 단위뿐 아니라  가지는 객체
- 시그니처 : 객체가 선언하는 모든 연산은 이름, 매개변수로 받아들이는 객체들, 연산의 반환 값을 명세, 이를 연산의 시그니처라 함  
- 동적 바인딩 : 같은 요청이라도 처리하는 객체에 따라 결과가 달라진다.



## 사전 지식
객체 구현 명세하기

### 재사용 기법 :  클래스 합성 < 객체 합성



전략 패턴
- Inteface : 연결하는 접점, 기능에 대한 선언과 구현을 분리할 때 사용, 기능을 사용하는 통로
- Delegate : 떠넘기다. 다른 객체의 기능을 사용하기 위해 하나의 객체 내에서 해당 객체를 구현해서 사용, 추상화를 통해 교환이 용이하게  
- Adapter : 기계, 기구 등을 다목적으로 사용하기 위한 부가기구
